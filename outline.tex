\documentclass[12pt,a4paper]{article}

% ==== 語言與字體設定 ====
\usepackage{xeCJK}
\usepackage{fontspec}
\setmainfont{Times New Roman}
\setCJKmainfont[AutoFakeBold,AutoFakeSlant]{Noto Serif CJK TC}

% ==== 頁面設定 ====
\usepackage{geometry}
\geometry{left=2.5cm,right=2.5cm,top=3cm,bottom=3cm}

% ==== 表格設定 ====
\usepackage{float}
\usepackage{booktabs}
\usepackage{array}
\usepackage{xltabular}
\usepackage{relsize}
\usepackage[tableposition=top]{caption}
\captionsetup[table]{position=top, skip=6pt}
\renewcommand{\arraystretch}{1.2}
\setlength{\tabcolsep}{5pt}
\usepackage{graphicx}

% ==== 自訂欄位型別 ====
\usepackage{ragged2e}
\newcolumntype{L}[1]{>{\RaggedRight\arraybackslash}p{#1}}
\newcolumntype{Y}{>{\RaggedRight\arraybackslash}X}

% ==== 共用表頭巨集 ====
\newcommand{\DictHeader}{
\toprule
\textbf{Column Name} & \textbf{Meaning} & \textbf{Data Type} & \textbf{Key} & \textbf{Constraint} & \textbf{Domain} \\
\midrule
}

% ==== 簡化標註 ====
\newcommand{\Enum}[1]{\texttt{\{#1\}}}
\newcommand{\Note}[1]{\textit{#1}}

% ==== 版面與排版優化 ====
\usepackage{microtype}
\setlength{\emergencystretch}{1em}
\sloppy
\setlength{\parskip}{0.6em}
\usepackage{enumitem}
\setlist[enumerate]{itemsep=0.25em, topsep=0.3em, parsep=0em, leftmargin=2em}
\setlist[itemize]{itemsep=0.25em, topsep=0.3em, parsep=0em, leftmargin=2em}

% ==== 其他常用套件 ====
\usepackage{url}
\def\UrlFont{\ttfamily\footnotesize}
\usepackage[hidelinks]{hyperref}

% ==== 代碼顯示套件 ====
\usepackage{listings}
\usepackage{xcolor}
\lstset{
    language=SQL,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    numbers=none,
    breaklines=true,
    frame=single,
    frameround=tttt,
    backgroundcolor=\color{gray!10},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    captionpos=b
}

% ==== 文件基本資訊 ====
\title{校園生活用品交換與買賣平台}
\author{
\textbf{Group 22} \\
B12705001\ 范嘉栩 \quad 
B12705021\ 周建凱 \\
B12705050\ 宋承陽 \\
\vspace{1em}
\normalsize 日期：November 1, 2025
}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{系統分析（System Analysis）}

\subsection{主題與動機（System Purpose \& Motivation）}

在現今的線上交易環境中，使用者獲取商品的方式日趨多元。除了傳統的現金購買，以物易物、混合交易等形式也逐漸興起，臉書社團等平台已展現出這類多元交易的可能性。然而，現有的多數交易平台仍存在明顯侷限——大多僅支援單向的購買流程，缺乏完善的物品交換機制與協商功能，無法滿足使用者多樣化的交易需求。

本系統特別針對大學生族群設計。大學生普遍經濟能力有限，對於課本、二手用品、電子產品等生活與學習資源有高度需求。透過整合「購買」與「交換」功能，使用者能同時扮演買家與賣家的雙重角色，根據自身需求自由提出交易請求——無論是現金交易、物品交換或混合模式，都能在同一平台上順暢完成。此設計不僅降低取得資源的經濟門檻，更能達成節省支出與資源再利用的雙重目標。

在技術層面，本系統採用結構化的資料庫設計與明確的交易流程規範，有效紀錄商品資訊、使用者請求關係與協商結果，確保資料一致性、可追蹤性與可稽核性，並為後續的推薦機制、信譽評價與營運分析奠定堅實基礎。

\subsection{系統功能（System Functions）}

本系統的主要目標是提供一個整合「購買」與「交換」的校園二手交易平台，使使用者能以彈性的方式取得與交換所需物品。依照系統角色，功能可區分為「功能設定說明」、「一般使用者功能」與「平台管理者功能」三大部分。

\subsubsection{功能設定說明（System Function Settings）}

為了確保交易流程的安全性與一致性，本系統在多項操作上設有明確規則與限制，主要包括以下幾點：

\begin{enumerate}
    \item \textbf{交易模式設定：}商品上架時，使用者必須選擇一種交易模式，包含「販售（Sale）」、「交換（Trade）」或「兩者皆可（Both）」。若選擇交換或混合模式，可輸入期望交換之物品描述（例如「電腦滑鼠」、「小說」、「宿舍電鍋」等）或者不限。
    
    \item \textbf{商品狀態（Status）限制：}每項商品的狀態皆由系統自動維護，分為 \textit{available}（可交易）、\textit{reserved}（預留中）、\textit{sold}（已售出）、\textit{exchanged}（已交換）及 \textit{removed}（已下架）。完成交易或被移除後，商品將無法再次被提出請求。
    
    \item \textbf{請求與撮合流程：}本系統的交易流程涵蓋「販售」、「交換」及「開放式許願」三種互動型態：
    \begin{itemize}
        \item 若使用者僅販售商品，其他人可直接提出購買請求（記錄於 TRADE\_REQUEST，類型為 Purchase）。
        \item 若使用者想以物易物但市場尚無對應物品，系統會建立一筆許願紀錄 TRADE\_WISH，表示其開放式需求。
        \item 若市場已有可交換商品，系統依情境區分：
        \begin{itemize}
            \item 若對方明確表示「想換該使用者的物品」，則此請求屬於 Request Target
            \item 若對方僅開放交換但未指定欲換之物，則此請求屬於 Request Offer
        \end{itemize}
        \item 當雙方確認交換條件或完成購買時，系統自動生成交易紀錄 TRANSACTION。
    \end{itemize}
    所有請求狀態均會被即時更新，若任一方拒絕或撤回，請求狀態改為 Cancelled 或 Rejected，不影響其他待處理請求。
    
    \item \textbf{交易紀錄保存：}所有已完成的交易紀錄皆永久保存在資料庫中，作為後續查詢、統計及信譽評價依據。此舉確保平台資料的可追蹤性與透明性。
    
    \item \textbf{分類與搜尋機制：}所有商品皆須隸屬於一個明確的分類（如：Textbooks、Electronics、Daily Use 等），使用者可透過分類、關鍵字或條件搜尋商品，以提升查找效率。
    
    \item \textbf{時間與狀態更新：}系統自動記錄商品上架日期 Post\_date、請求建立時間 Created\_at 及更新時間 Updated\_at，以利後續分析與查詢。
\end{enumerate}

\textbf{使用情境範例：}
\begin{itemize}
    \item 小明想出售微積分課本，設定交易模式為「Sale」，價格 300 元
    \item 小華想用電子辭典交換英文課本，設定交易模式為「Trade」
    \item 小美可接受現金或物品交換，設定交易模式為「Both」
\end{itemize}

上述設定確保平台運作邏輯一致、資料可追蹤，同時避免交易衝突與狀態錯誤。

\subsubsection{一般使用者功能（User Functions）}

一般使用者（User）為平台的主要參與者，具備以下功能：

\begin{enumerate}
    \item \textbf{註冊與登入：}使用者可於平台上註冊帳號、登入系統，並設定基本資料（姓名、電子郵件、聯絡方式等）。
    \item \textbf{商品上架：}使用者可新增商品資訊，包括商品名稱、分類、狀況、價格、描述、交易方式（販售／交換／混合）及圖片，完成上架。
    \item \textbf{瀏覽與搜尋：}使用者可依照分類、名稱或關鍵字搜尋商品，並瀏覽詳細資訊。
    \item \textbf{提出請求（購買／交換）：}使用者可對他人商品提出購買請求，或提供欲交換之物品並發送交換邀請。
    \item \textbf{管理交易請求：}使用者可查看自己提出與收到的請求，選擇接受、拒絕或取消。
    \item \textbf{查看交易紀錄：}使用者可查詢已完成或進行中的交易紀錄，包含交易對象、商品名稱、金額或交換內容。
    \item \textbf{修改與刪除商品：}若商品尚未成交，使用者可修改或下架該商品。
    \item \textbf{帳號管理：}使用者可更新個人資料、修改密碼或停用帳號。
\end{enumerate}

透過上述功能，使用者能以彈性方式發起與參與交易，並藉由結構化的交易流程確保安全性與透明度。

\subsubsection{平台管理者功能（Admin Functions）}

平台管理者（Admin）負責維護整體系統的穩定運作與資訊正確性，具備以下功能：

\begin{enumerate}
    \item \textbf{用戶管理：}管理者可檢視、停權或恢復使用者帳號，以維護平台秩序。
    \item \textbf{商品管理：}管理者可審核或刪除不當商品（例如違規、重複或含不當內容的上架物品）。
    \item \textbf{分類管理：}管理者可新增、修改或刪除商品分類，使平台分類結構保持清晰。
    \item \textbf{交易監控：}管理者可查詢所有交易紀錄，包括交易狀態與雙方帳號資訊，以便處理爭議或異常情況。
    \item \textbf{系統維護與分析：}管理者可進行資料備份、檢視統計報告，分析平台使用狀況（如熱門分類、交易量等）。
\end{enumerate}

綜合而言，本系統透過明確的權限分工與資料庫設計，建立一個兼顧使用者體驗與系統安全性的校園二手交易生態環境。









\section{系統設計（System Design）}
\subsection{實體關聯圖（ER Diagram）}
\begin{figure}[H]
    \centering
    \noindent
    \makebox[\textwidth][c]{%
        \includegraphics[width=1.05\textwidth, keepaspectratio]{ER_Diagram.png}
    }
    \caption{本系統之 ER Diagram（實體關聯圖）}
\end{figure}

在此 ER Diagram 中，共有九個主要實體（Entity），分別是 USER、PRODUCT、CATEGORY、TRADE\_REQUEST、TRANSACTION、TRADE\_WISH、REVIEW、MESSAGE 以及 REPORT，同時也包含一個特殊角色實體 ADMIN。這些實體之間透過多個關係（Relationship）彼此連結，例如使用者上架商品（OWN）、發送交易請求（REQUEST）、完成交易（COMPLETE）、發起許願（WISH）、撰寫評價（REVIEW）、傳送訊息（MESSAGE）及提出檢舉（REPORT）等。

USER 代表的是使用「校園生活用品交換與買賣平台」的任何人。任何使用者在進入系統前，皆須先註冊帳號，提供姓名、學號、電子郵件及密碼等基本資訊。註冊完成後，系統會自動為每位使用者分配唯一的 \texttt{User\_id}，作為後續所有交易與操作的識別依據。若該使用者同時負責管理系統或審核商品，則會在後端被設定為 ADMIN，此時該使用者便同時具有一般使用者（User）與平台管理員（Admin）兩種身份。

PRODUCT 代表使用者所上架的商品。每一項商品皆由一位使用者所擁有（Owner\_id 參考 USER），並歸屬於特定分類（Category\_id 參考 CATEGORY）。商品包含名稱、價格、狀況、圖片、上架日期與交易方式（販售、交換或混合）等屬性。若商品開放交換，使用者可以輸入期望交換的物品描述（Trade\_item），作為後續撮合的依據。

CATEGORY 則用來記錄商品的類別資訊，例如「教科書」、「電子產品」、「生活用品」等。每項商品必須歸屬於一個明確分類，以便後續搜尋與統計分析。

TRADE\_REQUEST 為交易請求的關聯實體，用以記錄使用者之間的互動。當某位使用者想購買或交換他人商品時，系統會產生一筆交易請求紀錄，其中包含請求者（Requester\_id）、目標商品（Target\_product\_id）及請求類型（Request\_type）等欄位。若為交換請求，還會紀錄該使用者提供的交換商品（Offered\_product\_id）。請求狀態會依交易流程變化，從 Pending、Accepted、Completed 至 Cancelled。

TRANSACTION 則對應於實際完成的交易紀錄。當請求雙方確認條件並完成交易後，系統會自動產生交易紀錄，其中包含完成日期、交易金額與付款狀態等欄位。此關聯可視為 TRADE\_REQUEST 的延伸，兩者呈現一對一關係。

TRADE\_WISH 表示使用者對尚未出現的商品提出的開放式交換需求。使用者可描述欲交換之物品名稱、類別與條件，系統會將該許願資訊公開，並在有相符商品上架時提供通知。此設計使交換流程不僅限於即時配對，也能支持延遲撮合的情境。

REVIEW 為交易評價實體，用於記錄使用者對已完成交易的評價與評論。當交易完成後，買賣雙方皆可對該筆交易進行評分（Rating）並撰寫評論（Comment），以建立平台的信譽機制。每筆交易可包含買方對賣方的評價，以及賣方對買方的評價，形成雙向評價系統。

MESSAGE 為訊息實體，用於記錄使用者之間的即時通訊內容。當使用者對商品提出交易請求後，買賣雙方可透過訊息功能進行協商、討論交易細節或確認交貨方式。每則訊息皆與特定的交易請求（TRADE\_REQUEST）關聯，確保對話脈絡清晰。

REPORT 為檢舉實體，用於記錄使用者對不當商品或詐騙行為的檢舉。使用者可針對特定商品或使用者提出檢舉，說明檢舉原因（如詐騙、不當內容、違規商品等），管理員可依據檢舉內容進行審核與處理，維護平台秩序與安全性。

ADMIN 為平台管理員，屬於特殊使用者。管理員可審核上架商品、刪除違規內容、管理分類、處理檢舉、公告規則與查看平台統計數據，以維護整體系統的安全與秩序。

整體而言，本系統的 ER Diagram 以 USER 為核心，透過多對多與一對多的關係串接其他實體，完整呈現使用者從上架、瀏覽、請求到完成交易的全流程互動。此結構亦為後續關聯式資料庫設計提供明確依據。



\subsection{關聯式資料庫綱目圖 （Relational Database Schema Diagram）}
\begin{figure}[H]
    \centering
    \noindent
    \makebox[\textwidth][c]{%
        \includegraphics[width=1.15\textwidth, keepaspectratio]{Relational_Schema.png}
    }
    \caption{本系統之 Relational Database Schema}
\end{figure}
整體 Schema架構共包含九張主要資料表：USER、CATEGORY、PRODUCT、TRADE\_REQUEST、TRANSACTION、TRADE\_WISH、REVIEW、MESSAGE、REPORT，以及一張平台管理權限表 ADMIN。

USER 關聯的主鍵（Primary Key, PK）為 \texttt{User\_id}，所有使用者的基本資料（姓名、學號、信箱、密碼等）皆依此識別。  
由於管理者身分為一般使用者的延伸，因此 ADMIN 關聯中同樣以 \texttt{User\_id} 作為外鍵（Foreign Key, FK），並以 \texttt{Role} 欄位標示管理權限層級（例如 PlatformAdmin、ClubAdmin）。

PRODUCT 關聯的主鍵為 \texttt{Product\_id}，外鍵包括 \texttt{Owner\_id}（參考 USER）與 \texttt{Category\_id}（參考 CATEGORY）。  
商品相關資訊如價格、描述、交易狀況、圖片網址等皆以屬性形式儲存。  
若該商品允許交換，\texttt{Trade\_item} 欄位會記錄期望交換之物品描述。  
商品下架或交易完成後，其狀態（Status）會由系統自動更新為 sold, removed 或 exchanged。
\newpage

CATEGORY 關聯則為靜態資料表，用以保存商品分類，主鍵為 \texttt{Category\_id}，每項分類皆對應多筆商品。

TRADE\_REQUEST 關聯是由使用者之間的 Request 關係轉換而來，主鍵為 \texttt{Request\_id}。  
其外鍵包括 \texttt{Requester\_id}（參考 USER）、\texttt{Target\_product\_id}（參考 PRODUCT）與 \texttt{Offered\_product\_id}（參考 PRODUCT）。  
此設計允許同時支援購買與交換兩種請求形式。  
當交易完成時，對應的請求會被標示為 Completed，並生成 TRANSACTION 紀錄。

TRANSACTION 關聯由 TRADE\_REQUEST 延伸而來，主鍵為 \texttt{Transaction\_id}，外鍵參考 \texttt{Request\_id}。  
此表用於記錄最終成交的交易，包括完成日期與付款狀態（Paid／Unpaid）。  
此外，為確保資料完整性，交易刪除或修改時將觸發對應的參照更新規則（Cascade／Set Null）。

TRADE\_WISH 關聯則由 TRADE\_WISH 實體轉換而來，用以紀錄使用者開放式的交換願望。  
主鍵為 \texttt{Wish\_id}，外鍵包括 \texttt{User\_id}（參考 USER）、\texttt{Offered\_product\_id}（參考 PRODUCT）與 \texttt{Desired\_category\_id}（參考 CATEGORY）。  
此設計支援使用者提出交換需求，即使尚未出現對應商品，系統仍可追蹤並在後續進行配對。

REVIEW 關聯由 REVIEW 實體轉換而來，主鍵為 \texttt{Review\_id}，外鍵包括 \texttt{Transaction\_id}（參考 TRANSACTION）、\texttt{Reviewer\_id}（參考 USER）與 \texttt{Reviewee\_id}（參考 USER）。  
此表用於記錄交易完成後的雙向評價，包含評分（Rating）與評論內容（Comment），建立平台信譽機制。

MESSAGE 關聯由 MESSAGE 實體轉換而來，主鍵為 \texttt{Message\_id}，外鍵包括 \texttt{Request\_id}（參考 TRADE\_REQUEST）、\texttt{Sender\_id}（參考 USER）與 \texttt{Receiver\_id}（參考 USER）。  
此表用於記錄買賣雙方針對特定交易請求的對話內容，支援即時協商與溝通功能。

REPORT 關聯由 REPORT 實體轉換而來，主鍵為 \texttt{Report\_id}，外鍵包括 \texttt{Reporter\_id}（參考 USER）、\texttt{Reported\_product\_id}（參考 PRODUCT，可為 NULL）與 \texttt{Reported\_user\_id}（參考 USER，可為 NULL）。  
此表用於記錄使用者對不當商品或詐騙行為的檢舉，管理員可依據檢舉內容進行審核與處理。

整體而言，本系統之關聯式資料庫結構已將 ER Diagram 的多對多與層級關係完整轉換為實際可實作的關聯模型。  
各表的主鍵、外鍵與觸發規則均清楚定義，能確保交易資料的一致性、可追蹤性與高正規化設計品質。




\newpage
\subsection{資料字典 （Data Dictionary）}
以下為本系統之資料字典：
在交易邏輯上，本系統同時支援「許願交換」、「目標交換」、「開放交換」與「直接購買」等多種互動情境。  
透過 TRADE\_WISH、TRANSACTION、TRADE\_REQUEST 三張表的設計，  
可完整覆蓋以下四種典型案例：

\begin{itemize}
    \item \textbf{情況 1：} 使用者想販售商品 → 建立 PRODUCT（Trade\_option = 'sale'）。
    \item \textbf{情況 2：} 想交換但市場尚無對應物品 → 建立 TRADE\_WISH。
    \item \textbf{情況 3：} 想交換且市場已有對應商品 → 建立 TRADE\_REQUEST。  
    若對方指定想換此物 → Request\_Target；  
    若對方僅開放交換 → Request\_Offer。
    \item \textbf{情況 4：} 直接購買現有商品 → 建立 TRADE\_REQUEST（Request\_type = 'Purchase'），完成後生成 TRANSACTION。
\end{itemize}



% ===================== USER 表 =====================
\begin{footnotesize}
\begin{xltabular}{\textwidth}{L{2.8cm} L{2.6cm} L{2cm} L{1cm} L{3cm} Y}
\DictHeader
User\_id       & 使用者代號     & bigint      & PK  & Not Null, Unique &  \\
User\_name     & 使用者名稱     & varchar(20) &     & Not Null         &  \\
Student\_id    & 學號           & varchar(15) &     & Not Null, Unique &  \\
Email          & 電子郵件       & varchar(50) &     & Not Null, Unique &  \\
Password       & 密碼           & varchar(15) &     & Not Null         &  \\
Phone          & 聯絡電話       & varchar(15) &     & Nullable         &  \\
Register\_date & 註冊日期       & date        &     & Not Null         &  \\
Status         & 帳號狀態       & varchar(10) &     & Default 'active' & \Enum{active, suspended} \\
\bottomrule
\caption{資料表 USER 的欄位資訊（使用者基本資料）}
\end{xltabular}
\end{footnotesize}
% ===================== CATEGORY 表 =====================
\begin{footnotesize}
\begin{xltabular}{\textwidth}{L{2.8cm} L{2.6cm} L{2cm} L{1cm} L{3cm} Y}
\DictHeader
Category\_id   & 商品分類代號 & int         & PK  & Auto Increment, Not Null &  \\
Category\_name & 商品分類名稱 & varchar(30) &     & Not Null & \Enum{Textbooks, Electronics, Clothing, Stationery, Daily\_Use, Others} \\
\bottomrule
\caption{資料表 CATEGORY 的欄位資訊}
\end{xltabular}
\end{footnotesize}

\newpage

% ===================== PRODUCT 表 =====================
\begin{footnotesize}
\begin{xltabular}{\textwidth}{L{2.8cm} L{2.6cm} L{2cm} L{1cm} L{3cm} Y}
\DictHeader
Product\_id       & 商品代號         & bigint       & PK  & Not Null, Unique &  \\
Owner\_id         & 上架者代號       & bigint       & FK  & Not Null         & USER(User\_id) \\
Category\_id      & 商品分類代號     & int          & FK  & Not Null         & CATEGORY(Category\_id) \\
Product\_name     & 商品名稱         & varchar(50)  &     & Not Null         &  \\
Price             & 商品價格         & int          &     & Nullable         & \Note{$\ge 0$；僅販售時使用} \\
Trade\_option     & 交易方式         & varchar(10)  &     & Default 'sale'   & \Enum{sale, trade, both} \\
Condition         & 商品狀況         & varchar(20)  &     & Not Null         & \Enum{Brand\_New, Good, Used} \\
Description       & 商品描述         & varchar(100) &     &                  &  \\
Trade\_item       & 欲交換之物品     & varchar(100) &     & Nullable         & \Note{當 Trade\_option 為 trade/both 時填寫} \\
Status            & 銷售狀態         & varchar(20)  &     & Default 'available' & \Enum{available, reserved, sold, exchanged, removed} \\
Image\_url        & 圖片網址         & varchar(255) &     &                  &  \\
Post\_date        & 上架日期         & datetime     &     & Not Null         &  \\
\midrule
\multicolumn{4}{l}{\textbf{Referential triggers}} & \textbf{On Delete} & \textbf{On Update} \\
\multicolumn{4}{l}{Owner\_id: USER(User\_id)} & Cascade & Cascade \\
\multicolumn{4}{l}{Category\_id: CATEGORY(Category\_id)} & Restrict & Cascade \\
\bottomrule
\caption{資料表 PRODUCT 的欄位資訊}
\end{xltabular}
\end{footnotesize}


% ===================== TRANSACTION 表 =====================
\begin{footnotesize}
\begin{xltabular}{\textwidth}{L{2.8cm} L{2.6cm} L{2cm} L{1cm} L{3cm} Y}
\DictHeader
Transaction\_id      & 交易紀錄代號       & bigint      & PK  & Not Null, Unique &  \\
Request\_id          & 對應請求代號       & bigint      & FK  & Not Null         & TRADE\_REQUEST(Request\_id) \\
Target\_product\_id  & 目標商品代號       & bigint      & FK  & Not Null         & PRODUCT(Product\_id) \\
Offered\_product\_id & 提供商品代號       & bigint      & FK  & Nullable         & PRODUCT(Product\_id)；若為購買則為 NULL \\
Total\_price         & 交易金額           & int         &     & Nullable         & 僅購買類型使用 \\
Complete\_date       & 完成日期           & datetime    &     & Not Null         &  \\
Payment\_status      & 付款狀態           & varchar(10) &     & Default 'Unpaid' & \Enum{Paid, Unpaid, NA} \\
\midrule
\multicolumn{4}{l}{\textbf{Referential triggers}} & \textbf{On Delete} & \textbf{On Update} \\
\multicolumn{4}{l}{Request\_id: TRADE\_REQUEST(Request\_id)} & Cascade & Cascade \\
\multicolumn{4}{l}{Target\_product\_id: PRODUCT(Product\_id)} & Cascade & Cascade \\
\multicolumn{4}{l}{Offered\_product\_id: PRODUCT(Product\_id)} & Set Null & Cascade \\
\bottomrule
\caption{資料表 TRANSACTION 的欄位資訊（記錄完成的交易或購買）}
\end{xltabular}
\end{footnotesize}
\newpage






% ===================== TRADE_WISH 表 =====================
\begin{footnotesize}
\begin{xltabular}{\textwidth}{L{2.8cm} L{2.6cm} L{2cm} L{1cm} L{3cm} Y}
\DictHeader
Wish\_id             & 許願代號              & bigint      & PK  & Not Null, Unique &  \\
User\_id             & 使用者代號            & bigint      & FK  & Not Null         & USER(User\_id) \\
Offered\_product\_id & 提供交換商品代號      & bigint      & FK  & Not Null         & PRODUCT(Product\_id)；屬於該 User \\
Image\_url           & 交換商品圖片網址      & varchar(255)&     &                  &  \\
Desired\_text        & 欲交換之物品描述      & varchar(100)&     & Not Null         & 文字敘述，如「鉛筆」或「遊戲機」 \\
Desired\_category\_id& 欲交換物品分類代號    & int         & FK  & Nullable         & CATEGORY(Category\_id) \\
Status               & 許願狀態              & varchar(15) &     & Default 'Active' & \Enum{Active, Matched, Cancelled} \\
Created\_at          & 建立時間              & datetime    &     & Not Null         &  \\
Updated\_at          & 更新時間              & datetime    &     & Not Null         &  \\
\midrule
\multicolumn{4}{l}{\textbf{Referential triggers}} & \textbf{On Delete} & \textbf{On Update} \\
\multicolumn{4}{l}{User\_id: USER(User\_id)} & Cascade & Cascade \\
\multicolumn{4}{l}{Offered\_product\_id: PRODUCT(Product\_id)} & Cascade & Cascade \\
\multicolumn{4}{l}{Desired\_category\_id: CATEGORY(Category\_id)} & Set Null & Cascade \\
\bottomrule
\caption{資料表 TRADE\_WISH 的欄位資訊（使用者開放式徵求交換）}
\end{xltabular}
\end{footnotesize}

\newpage

% ===================== TRADE_REQUEST 表 =====================
\begin{footnotesize}
\begin{xltabular}{\textwidth}{L{2.8cm} L{2.6cm} L{2cm} L{1cm} L{3cm} Y}
\DictHeader
Request\_id          & 請求代號            & bigint      & PK  & Not Null, Unique &  \\
Requester\_id        & 提案者代號          & bigint      & FK  & Not Null         & USER(User\_id) \\
Target\_product\_id  & 目標商品代號        & bigint      & FK  & Not Null         & PRODUCT(Product\_id)；trade\_option='trade'或'both' \\
Offered\_product\_id & 提供交換之商品代號  & bigint      & FK  & Nullable         & PRODUCT(Product\_id)；僅當 Request\_type='Trade' 時有值 \\
Request\_type        & 請求類型            & varchar(10) &     & Not Null         & \Enum{Purchase, Trade} \\
Offer\_price         & 出價金額            & int         &     & Nullable         & 僅當 Request\_type='Purchase' 時使用 \\
Status               & 請求狀態            & varchar(15) &     & Default 'Pending' & \Enum{Pending, Accepted, Rejected, Completed, Cancelled} \\
Message              & 提案訊息            & varchar(255)&     & Nullable         & 可選文字補充說明 \\
Created\_at          & 建立時間            & datetime    &     & Not Null         &  \\
Updated\_at          & 更新時間            & datetime    &     & Not Null         &  \\
\midrule
\multicolumn{4}{l}{\textbf{Referential triggers}} & \textbf{On Delete} & \textbf{On Update} \\
\multicolumn{4}{l}{Requester\_id: USER(User\_id)} & Cascade & Cascade \\
\multicolumn{4}{l}{Target\_product\_id: PRODUCT(Product\_id)} & Cascade & Cascade \\
\multicolumn{4}{l}{Offered\_product\_id: PRODUCT(Product\_id)} & Set Null & Cascade \\
\bottomrule
\caption{資料表 TRADE\_REQUEST 的欄位資訊（使用者之間的交易／購買提案）}
\end{xltabular}
\end{footnotesize}

% ===================== ADMIN 表 =====================
\begin{footnotesize}
\begin{xltabular}{\textwidth}{L{2.8cm} L{2.6cm} L{2cm} L{1cm} L{3cm} Y}
\DictHeader
Admin\_id & 管理者代號   & bigint      & PK  & Not Null &  \\
User\_id  & 使用者代號   & bigint      & FK  & Not Null & USER(User\_id) \\
Role      & 權限分類     & varchar(20) &     & Not Null & \Enum{PlatformAdmin, ClubAdmin} \\
\midrule
\multicolumn{4}{l}{\textbf{Referential triggers}} & \textbf{On Delete} & \textbf{On Update} \\
\multicolumn{4}{l}{User\_id: USER(User\_id)} & Cascade & Cascade \\
\bottomrule
\caption{資料表 ADMIN 的欄位資訊（平台管理權限）}
\end{xltabular}
\end{footnotesize}

\newpage

% ===================== REVIEW 表 =====================
\begin{footnotesize}
\begin{xltabular}{\textwidth}{L{2.8cm} L{2.6cm} L{2cm} L{1cm} L{3cm} Y}
\DictHeader
Review\_id      & 評價代號         & bigint      & PK  & Not Null, Unique &  \\
Transaction\_id & 交易紀錄代號     & bigint      & FK  & Not Null         & TRANSACTION(Transaction\_id) \\
Reviewer\_id    & 評價者代號       & bigint      & FK  & Not Null         & USER(User\_id) \\
Reviewee\_id    & 被評價者代號     & bigint      & FK  & Not Null         & USER(User\_id) \\
Rating          & 評分             & int         &     & Not Null         & \Note{1-5 分} \\
Comment         & 評論內容         & varchar(500)&     & Nullable         &  \\
Created\_at     & 建立時間         & datetime    &     & Not Null         &  \\
\midrule
\multicolumn{4}{l}{\textbf{Referential triggers}} & \textbf{On Delete} & \textbf{On Update} \\
\multicolumn{4}{l}{Transaction\_id: TRANSACTION(Transaction\_id)} & Cascade & Cascade \\
\multicolumn{4}{l}{Reviewer\_id: USER(User\_id)} & Cascade & Cascade \\
\multicolumn{4}{l}{Reviewee\_id: USER(User\_id)} & Cascade & Cascade \\
\bottomrule
\caption{資料表 REVIEW 的欄位資訊（交易評價與評論）}
\end{xltabular}
\end{footnotesize}

\newpage

% ===================== MESSAGE 表 =====================
\begin{footnotesize}
\begin{xltabular}{\textwidth}{L{2.8cm} L{2.6cm} L{2cm} L{1cm} L{3cm} Y}
\DictHeader
Message\_id   & 訊息代號         & bigint      & PK  & Not Null, Unique &  \\
Request\_id   & 交易請求代號     & bigint      & FK  & Not Null         & TRADE\_REQUEST(Request\_id) \\
Sender\_id    & 發送者代號       & bigint      & FK  & Not Null         & USER(User\_id) \\
Receiver\_id  & 接收者代號       & bigint      & FK  & Not Null         & USER(User\_id) \\
Content       & 訊息內容         & varchar(500)&     & Not Null         &  \\
Is\_read      & 是否已讀         & boolean     &     & Default false    &  \\
Sent\_at      & 發送時間         & datetime    &     & Not Null         &  \\
\midrule
\multicolumn{4}{l}{\textbf{Referential triggers}} & \textbf{On Delete} & \textbf{On Update} \\
\multicolumn{4}{l}{Request\_id: TRADE\_REQUEST(Request\_id)} & Cascade & Cascade \\
\multicolumn{4}{l}{Sender\_id: USER(User\_id)} & Cascade & Cascade \\
\multicolumn{4}{l}{Receiver\_id: USER(User\_id)} & Cascade & Cascade \\
\bottomrule
\caption{資料表 MESSAGE 的欄位資訊（買賣雙方訊息對話）}
\end{xltabular}
\end{footnotesize}

\newpage

% ===================== REPORT 表 =====================
\begin{footnotesize}
\begin{xltabular}{\textwidth}{L{2.8cm} L{2.6cm} L{2cm} L{1cm} L{3cm} Y}
\DictHeader
Report\_id           & 檢舉代號         & bigint      & PK  & Not Null, Unique &  \\
Reporter\_id         & 檢舉者代號       & bigint      & FK  & Not Null         & USER(User\_id) \\
Reported\_product\_id& 被檢舉商品代號   & bigint      & FK  & Nullable         & PRODUCT(Product\_id)；若檢舉商品則有值 \\
Reported\_user\_id    & 被檢舉使用者代號 & bigint      & FK  & Nullable         & USER(User\_id)；若檢舉使用者則有值 \\
Report\_type         & 檢舉類型         & varchar(20) &     & Not Null         & \Enum{Scam, Inappropriate, Fraud, Other} \\
Description          & 檢舉描述         & varchar(500)&     & Not Null         &  \\
Status               & 處理狀態         & varchar(15) &     & Default 'Pending' & \Enum{Pending, Under\_Review, Resolved, Rejected} \\
Created\_at          & 建立時間         & datetime    &     & Not Null         &  \\
Resolved\_at         & 處理完成時間     & datetime    &     & Nullable         &  \\
\midrule
\multicolumn{4}{l}{\textbf{Referential triggers}} & \textbf{On Delete} & \textbf{On Update} \\
\multicolumn{4}{l}{Reporter\_id: USER(User\_id)} & Cascade & Cascade \\
\multicolumn{4}{l}{Reported\_product\_id: PRODUCT(Product\_id)} & Set Null & Cascade \\
\multicolumn{4}{l}{Reported\_user\_id: USER(User\_id)} & Set Null & Cascade \\
\bottomrule
\caption{資料表 REPORT 的欄位資訊（使用者檢舉不當商品或行為）}
\end{xltabular}
\end{footnotesize}

\newpage

\subsection{正規化分析（Normalization Analysis）}

在設計本系統的關聯式資料庫時，我們檢視整體綱目（database schema）是否符合正規化（Normalization）的設計原則。以下依序從第一正規式（1NF）至第四正規式（4NF）說明本系統之關聯如何滿足相關規則，並舉例說明轉換過程。

\paragraph{第一正規式（1NF）}
若關聯中的所有屬性皆為「單一且不可再分」的基本值（simple and single-valued），則該關聯滿足 1NF。在本系統中，所有資料表的欄位皆為原子屬性（atomic attributes），不存在複合屬性（composite attributes）或多值屬性（multi-valued attributes）。

\textbf{具體例子：}例如，使用者的多角色（Admin／User）已以獨立的 ADMIN 資料表描述，而商品的多分類、交易狀態或交換項目也以單一屬性欄位呈現。若將使用者的多個角色儲存在同一欄位中（如 "Admin,User"），將違反 1NF，因此我們將其獨立成 ADMIN 表。

\paragraph{第二正規式（2NF）}
若關聯已符合 1NF，且所有非鍵屬性（non-prime attributes）皆完全功能相依（fully functional dependency）於候選鍵（candidate key），則滿足 2NF。本系統的各關聯中，主鍵多為單一欄位（如 User\_id、Product\_id、Request\_id 等），因此所有非鍵屬性均完全依賴於該主鍵，並無部分依賴情形。

\textbf{具體例子：}在 PRODUCT 表中，所有屬性（Product\_name、Price、Condition 等）都完全依賴於主鍵 Product\_id，不存在部分依賴的情況。

\paragraph{第三正規式（3NF）}
若關聯已符合 2NF，且所有非鍵屬性皆不會遞移相依（transitive dependency）於主鍵，則該關聯滿足 3NF。在本系統設計中，所有非鍵屬性均直接依賴其主鍵，不存在「屬性 → 屬性」的間接依賴關係。

\textbf{具體例子：}例如，Product\_name 與 Category\_id 皆直接依賴於 Product\_id，而不互相依賴；User\_name 與 Email 也直接依賴 User\_id。若將商品分類名稱直接儲存於 PRODUCT 表中，當分類名稱需要更新時，必須更新所有相關商品，將違反 3NF，因此我們透過 Category\_id 外鍵參考獨立的 CATEGORY 表。

\paragraph{BCNF（Boyce–Codd Normal Form）}
BCNF 的條件比 3NF 更嚴謹：若關聯中所有的函數相依（functional dependency）都滿足「左側屬性集合為超級鍵（superkey）」的條件，則該關聯滿足 BCNF。經檢視各關聯的主鍵與外鍵依賴關係，所有函數相依關係之決定因素皆為該關聯的超級鍵，因此本系統亦符合 BCNF。

\paragraph{第四正規式（4NF）}
若一個關聯不存在多值相依（multi-valued dependency），則滿足第四正規式。由於本系統所有多值特性（例如使用者的多角色、商品的多分類）皆已獨立成不同關聯（如 ADMIN 表或分類表 CATEGORY），各表中亦無重複或多值集合存在，因此可確定所有關聯皆符合 4NF。

\newpage

\section{重要功能與對應 SQL 指令（Important Functions and Corresponding SQL Commands）}

本節將列出本系統中使用者與管理員功能的 SQL 指令，並說明特定情境與系統級指令。

\subsection{使用者功能（Functions for Users）}

\subsubsection{新增商品（Add Product）}

若要實現此功能，假設情境為「使用者代號 Owner\_id '1001' 想新增一筆商品，商品名稱 Product\_name 為 '微積分課本'，分類 Category\_id 為 '1'（Textbooks），價格 Price 為 '300'，交易方式 Trade\_option 為 'sale'，商品狀況 Condition 為 'Good'，描述 Description 為 '使用一學期，狀況良好'，上架日期 Post\_date 為 '2024-11-01 10:00:00'。」則對應的 SQL 指令如下，系統會在 PRODUCT 資料表中新增一筆商品資訊。

\begin{lstlisting}[language=SQL]
Insert Into PRODUCT (Owner_id, Category_id, Product_name, Price, 
                     Trade_option, Condition, Description, Post_date)
Values (1001, 1, '微積分課本', 300, 'sale', 'Good', 
        '使用一學期，狀況良好', '2024-11-01 10:00:00');
\end{lstlisting}

Listing 1: 新增商品 SQL 指令

\subsubsection{查詢可交易商品（Query Available Products）}

若要實現此功能，假設情境為「某使用者想查詢狀態為 'available' 且交易方式為 'sale' 或 'both' 的商品。」則對應的 SQL 指令如下，系統會執行該查詢，並回傳符合條件的商品資訊，供使用者選擇。

\begin{lstlisting}[language=SQL]
Select *
From PRODUCT
Where Status = 'available'
And (Trade_option = 'sale' Or Trade_option = 'both');
\end{lstlisting}

Listing 2: 查詢可交易商品 SQL 指令

\subsubsection{提出交易請求（Create Trade Request）}

若要實現此功能，假設情境為「使用者代號 Requester\_id '2001' 想對商品代號 Target\_product\_id '5001' 提出購買請求，請求類型 Request\_type 為 'Purchase'，出價金額 Offer\_price 為 '280'，建立時間 Created\_at 為 '2024-11-02 14:30:00'。若該商品為可交易狀態，系統會將該請求加入 TRADE\_REQUEST 資料表；否則，系統退回此申請。」則對應的 SQL 指令如下。

\begin{lstlisting}[language=SQL]
Insert Into TRADE_REQUEST (Requester_id, Target_product_id, 
                          Request_type, Offer_price, Created_at, Updated_at)
Values (2001, 5001, 'Purchase', 280, '2024-11-02 14:30:00', 
        '2024-11-02 14:30:00');
\end{lstlisting}

Listing 3: 提出交易請求 SQL 指令

\subsubsection{接受交易請求（Accept Trade Request）}

若要實現此功能，假設情境為「商品擁有者想接受請求代號 Request\_id '3001' 的交易請求。」則對應的 SQL 指令如下，系統會更新 TRADE\_REQUEST 資料表中該請求的狀態為 'Accepted'，並更新 Updated\_at 時間。

\begin{lstlisting}[language=SQL]
Update TRADE_REQUEST
Set Status = 'Accepted', Updated_at = Now()
Where Request_id = 3001;
\end{lstlisting}

Listing 4: 接受交易請求 SQL 指令

\subsubsection{取消交易請求（Cancel Trade Request）}

若要實現此功能，假設情境為「使用者代號 Requester\_id '2001' 想要取消自己提出的請求代號 Request\_id '3002' 的交易請求。」則對應的 SQL 指令如下，系統會在 TRADE\_REQUEST 資料表中更新該請求狀態為 'Cancelled'。

\begin{lstlisting}[language=SQL]
Update TRADE_REQUEST
Set Status = 'Cancelled', Updated_at = Now()
Where Request_id = 3002 And Requester_id = 2001;
\end{lstlisting}

Listing 5: 取消交易請求 SQL 指令

\subsubsection{查詢使用者提出的交易請求（Query User's Trade Requests）}

若要實現此功能，假設情境為「使用者代號 User\_id '2001' 想要查看自己提出的所有交易請求。」則對應的 SQL 指令如下，系統會執行該查詢，並回傳包含該使用者提出的所有交易請求相關資訊。

\begin{lstlisting}[language=SQL]
Select tr.*, p.Product_name, u.User_name As Owner_name
From TRADE_REQUEST As tr
Join PRODUCT As p On tr.Target_product_id = p.Product_id
Join USER As u On p.Owner_id = u.User_id
Where tr.Requester_id = 2001;
\end{lstlisting}

Listing 6: 查詢使用者提出的交易請求 SQL 指令

\subsubsection{查詢使用者收到的交易請求（Query Received Trade Requests）}

若要實現此功能，假設情境為「使用者代號 User\_id '1001' 想要查看自己商品收到的所有交易請求。」則對應的 SQL 指令如下，系統會執行該查詢，並回傳包含該使用者商品收到的所有交易請求相關資訊。

\begin{lstlisting}[language=SQL]
Select tr.*, p.Product_name, u.User_name As Requester_name
From TRADE_REQUEST As tr
Join PRODUCT As p On tr.Target_product_id = p.Product_id
Join USER As u On tr.Requester_id = u.User_id
Where p.Owner_id = 1001;
\end{lstlisting}

Listing 7: 查詢使用者收到的交易請求 SQL 指令

\subsubsection{完成交易（Complete Transaction）}

若要實現此功能，假設情境為「當交易請求 Request\_id '3001' 被接受後，系統建立一筆交易紀錄，交易金額 Total\_price 為 '280'，完成日期 Complete\_date 為 '2024-11-05 16:00:00'。」則對應的 SQL 指令如下，系統會在 TRANSACTION 資料表中新增一筆交易紀錄，並更新對應的 TRADE\_REQUEST 狀態為 'Completed'，同時更新商品狀態為 'sold' 或 'exchanged'。

\begin{lstlisting}[language=SQL]
Begin Transaction;

Insert Into TRANSACTION (Request_id, Target_product_id, 
                        Offered_product_id, Total_price, 
                        Complete_date, Payment_status)
Select tr.Request_id, tr.Target_product_id, tr.Offered_product_id,
       tr.Offer_price, '2024-11-05 16:00:00', 'Unpaid'
From TRADE_REQUEST As tr
Where tr.Request_id = 3001;

Update TRADE_REQUEST
Set Status = 'Completed', Updated_at = Now()
Where Request_id = 3001;

Update PRODUCT
Set Status = 'sold'
Where Product_id = (Select Target_product_id 
                    From TRADE_REQUEST 
                    Where Request_id = 3001);

Commit;
\end{lstlisting}

Listing 8: 完成交易 SQL 指令

\subsubsection{查詢交易紀錄（Query Transaction History）}

若要實現此功能，假設情境為「使用者代號 User\_id '2001' 想要查看自己參與過的所有交易紀錄。」則對應的 SQL 指令如下，系統會執行該查詢，並回傳包含該使用者參與的所有交易紀錄相關資訊。

\begin{lstlisting}[language=SQL]
Select t.*, p1.Product_name As Target_product_name,
       p2.Product_name As Offered_product_name,
       tr.Request_type
From TRANSACTION As t
Join TRADE_REQUEST As tr On t.Request_id = tr.Request_id
Join PRODUCT As p1 On t.Target_product_id = p1.Product_id
Left Join PRODUCT As p2 On t.Offered_product_id = p2.Product_id
Where tr.Requester_id = 2001 Or p1.Owner_id = 2001;
\end{lstlisting}

Listing 9: 查詢交易紀錄 SQL 指令

\subsubsection{新增評價（Add Review）}

若要實現此功能，假設情境為「使用者代號 Reviewer\_id '2001' 對交易代號 Transaction\_id '4001' 進行評價，被評價者代號 Reviewee\_id 為 '1001'，評分 Rating 為 '5'，評論 Comment 為 '交易順利，商品狀況良好'，建立時間 Created\_at 為 '2024-11-06 10:00:00'。」則對應的 SQL 指令如下，系統會在 REVIEW 資料表中新增一筆評價紀錄。

\begin{lstlisting}[language=SQL]
Insert Into REVIEW (Transaction_id, Reviewer_id, Reviewee_id, 
                   Rating, Comment, Created_at)
Values (4001, 2001, 1001, 5, '交易順利，商品狀況良好', 
        '2024-11-06 10:00:00');
\end{lstlisting}

Listing 10: 新增評價 SQL 指令

\subsubsection{查詢商品評價（Query Product Reviews）}

若要實現此功能，假設情境為「某使用者想查看使用者代號 User\_id '1001' 收到的所有評價。」則對應的 SQL 指令如下，系統會執行該查詢，並回傳包含該使用者收到的所有評價相關資訊。

\begin{lstlisting}[language=SQL]
Select r.*, u.User_name As Reviewer_name, t.Transaction_id
From REVIEW As r
Join USER As u On r.Reviewer_id = u.User_id
Join TRANSACTION As t On r.Transaction_id = t.Transaction_id
Where r.Reviewee_id = 1001
Order By r.Created_at Desc;
\end{lstlisting}

Listing 11: 查詢商品評價 SQL 指令

\subsubsection{發送訊息（Send Message）}

若要實現此功能，假設情境為「使用者代號 Sender\_id '2001' 想對交易請求 Request\_id '3001' 的接收者 Receiver\_id '1001' 發送訊息，訊息內容 Content 為 '請問何時方便面交？'，發送時間 Sent\_at 為 '2024-11-03 09:15:00'。」則對應的 SQL 指令如下，系統會在 MESSAGE 資料表中新增一筆訊息紀錄。

\begin{lstlisting}[language=SQL]
Insert Into MESSAGE (Request_id, Sender_id, Receiver_id, 
                     Content, Sent_at)
Values (3001, 2001, 1001, '請問何時方便面交？', 
        '2024-11-03 09:15:00');
\end{lstlisting}

Listing 12: 發送訊息 SQL 指令

\subsubsection{查詢對話紀錄（Query Message History）}

若要實現此功能，假設情境為「使用者代號 User\_id '2001' 想查看與交易請求 Request\_id '3001' 相關的所有訊息。」則對應的 SQL 指令如下，系統會執行該查詢，並回傳包含該交易請求的所有訊息對話紀錄。

\begin{lstlisting}[language=SQL]
Select m.*, u1.User_name As Sender_name, u2.User_name As Receiver_name
From MESSAGE As m
Join USER As u1 On m.Sender_id = u1.User_id
Join USER As u2 On m.Receiver_id = u2.User_id
Where m.Request_id = 3001
Order By m.Sent_at Asc;
\end{lstlisting}

Listing 13: 查詢對話紀錄 SQL 指令

\subsubsection{提出檢舉（Create Report）}

若要實現此功能，假設情境為「使用者代號 Reporter\_id '2001' 想檢舉商品代號 Reported\_product\_id '5002'，檢舉類型 Report\_type 為 'Scam'，檢舉描述 Description 為 '商品描述與實際不符'，建立時間 Created\_at 為 '2024-11-04 11:20:00'。」則對應的 SQL 指令如下，系統會在 REPORT 資料表中新增一筆檢舉紀錄。

\begin{lstlisting}[language=SQL]
Insert Into REPORT (Reporter_id, Reported_product_id, 
                   Reported_user_id, Report_type, Description, Created_at)
Values (2001, 5002, NULL, 'Scam', '商品描述與實際不符', 
        '2024-11-04 11:20:00');
\end{lstlisting}

Listing 14: 提出檢舉 SQL 指令

\subsubsection{查詢課程（Query Products by Category）}

若要實現此功能，假設情境為「某使用者想透過兩個條件，商品分類 Category\_name 為 'Textbooks' 或商品名稱 Product\_name 內有 '微積分' 來查詢商品。」則對應的 SQL 指令如下，系統會執行該查詢，並回傳符合這些條件的商品資訊。

\begin{lstlisting}[language=SQL]
Select p.*, c.Category_name
From PRODUCT As p
Join CATEGORY As c On p.Category_id = c.Category_id
Where c.Category_name = 'Textbooks'
Or p.Product_name Like '%微積分%';
\end{lstlisting}

Listing 15: 查詢商品 SQL 指令

\subsection{管理員功能（Functions for Admin）}

\subsubsection{管理商品（增刪改查）}

\paragraph{刪除商品（Delete Product）}

若要實現此功能，假設情境為「某管理員想刪除代號 Product\_id 為 '5003' 的商品資訊。」則對應的 SQL 指令如下，系統會在 PRODUCT 資料表中刪除該商品的資訊。

\begin{lstlisting}[language=SQL]
Delete From PRODUCT
Where Product_id = 5003;
\end{lstlisting}

Listing 16: 刪除商品 SQL 指令

\paragraph{更新商品狀態（Update Product Status）}

若要實現此功能，假設情境為「某管理員想要更改商品代號 Product\_id 為 '5004' 的商品狀態，將其狀態 Status 改為 'removed'。」則對應的 SQL 指令如下，系統會更新 PRODUCT 資料表中該商品的狀態欄位資訊。

\begin{lstlisting}[language=SQL]
Update PRODUCT
Set Status = 'removed'
Where Product_id = 5004;
\end{lstlisting}

Listing 17: 更新商品狀態 SQL 指令

\paragraph{查詢商品（Query Products）}

若要實現此功能，假設情境為「某管理員想要查詢狀態 Status 為 'available' 的所有商品。」則對應的 SQL 指令如下，系統會執行該查詢，並回傳符合條件的商品資訊。

\begin{lstlisting}[language=SQL]
Select *
From PRODUCT
Where Status = 'available';
\end{lstlisting}

Listing 18: 查詢商品 SQL 指令

\subsubsection{查詢使用者資訊（Query User Information）}

若要實現此功能，假設情境為「某管理員想要查詢使用者代號 User\_id 為 '1001' 的使用者資訊。」則對應的 SQL 指令如下，系統會執行該查詢，並回傳特定使用者的相關資訊。

\begin{lstlisting}[language=SQL]
Select *
From USER
Where User_id = 1001;
\end{lstlisting}

Listing 19: 查詢使用者資訊 SQL 指令

\subsubsection{處理檢舉（Handle Report）}

若要實現此功能，假設情境為「某管理員想要將檢舉代號 Report\_id 為 '6001' 的處理狀態 Status 改為 'Resolved'，並記錄處理完成時間 Resolved\_at 為 '2024-11-07 15:30:00'。」則對應的 SQL 指令如下，系統會更新 REPORT 資料表中該檢舉的處理狀態。

\begin{lstlisting}[language=SQL]
Update REPORT
Set Status = 'Resolved', Resolved_at = '2024-11-07 15:30:00'
Where Report_id = 6001;
\end{lstlisting}

Listing 20: 處理檢舉 SQL 指令

\subsubsection{查詢待處理檢舉（Query Pending Reports）}

若要實現此功能，假設情境為「某管理員想要查詢所有狀態 Status 為 'Pending' 的檢舉。」則對應的 SQL 指令如下，系統會執行該查詢，並回傳所有待處理的檢舉資訊。

\begin{lstlisting}[language=SQL]
Select r.*, u1.User_name As Reporter_name, 
       u2.User_name As Reported_user_name, p.Product_name
From REPORT As r
Join USER As u1 On r.Reporter_id = u1.User_id
Left Join USER As u2 On r.Reported_user_id = u2.User_id
Left Join PRODUCT As p On r.Reported_product_id = p.Product_id
Where r.Status = 'Pending'
Order By r.Created_at Desc;
\end{lstlisting}

Listing 21: 查詢待處理檢舉 SQL 指令

\subsection{系統級指令（System-level Commands）}

\subsubsection{更新商品狀態（Update Product Status Automatically）}

若要實現此功能，假設情境為「系統將所有已完成交易（TRANSACTION 中存在）的商品狀態 Status 更改為 'sold' 或 'exchanged'（依據交易類型）。」則對應的 SQL 指令如下，系統會更新 PRODUCT 表中已完成交易的商品狀態欄位。

\begin{lstlisting}[language=SQL]
Update PRODUCT As p
Join TRANSACTION As t On p.Product_id = t.Target_product_id
Set p.Status = Case
    When t.Offered_product_id Is Not Null Then 'exchanged'
    Else 'sold'
End
Where p.Status = 'reserved';
\end{lstlisting}

Listing 22: 更新商品狀態 SQL 指令

\subsubsection{確認商品是否已被預約（Confirm if Product is Reserved）}

若要實現此功能，假設情境為「查詢商品代號 Product\_id 為 '5001' 的商品是否已有狀態為 'Accepted' 或 'Pending' 的交易請求，若已被預約回傳 1 (True)，若沒有預約回傳 0 (False)。」則對應的 SQL 指令如下。

\begin{lstlisting}[language=SQL]
Select
Case
    When Exists
    (
        Select *
        From TRADE_REQUEST As tr
        Where tr.Target_product_id = 5001
        And tr.Status In ('Pending', 'Accepted')
    )
    Then 1
    Else 0
End As Is_Reserved;
\end{lstlisting}

Listing 23: 確認商品是否已被預約 SQL 指令

\newpage

\section{SQL 指令效能優化與索引建立分析（SQL Command Performance Optimization and Index Creation Analysis）}

\subsection{在 PRODUCT 中加入商品狀態的索引}

在本系統中，最常使用的功能為「查詢可交易商品」。為了優化效能，如 3.2.1 所示，需要判斷商品是否為「可交易狀態」。由於「商品狀態」（Status）在資料庫中原本是分散的，建立索引應能更有效率地檢索可交易商品。

為了優化效能，在 PRODUCT 中為「Status」欄位建立索引，語法如下。

\begin{lstlisting}[language=SQL]
Create Index idx_product_status
On PRODUCT (Status);
\end{lstlisting}

Listing 24: 建立商品狀態索引

\subsection{在 TRADE\_REQUEST 中加入請求狀態、目標商品的索引}

在本系統中，TRADE\_REQUEST 表包含大量的交易請求資料。此表儲存使用者之間的交易請求紀錄。諸如「查詢使用者提出的交易請求」、「查詢使用者收到的交易請求」、「確認商品是否已被預約」等操作，都需要搜尋此表，且經常基於「請求狀態」（Status）與「目標商品」（Target\_product\_id）進行查詢。

為了有效優化效能，在此表中為「Status」與「Target\_product\_id」欄位建立索引，語法如下。

\begin{lstlisting}[language=SQL]
Create Index idx_request_status_product
On TRADE_REQUEST (Status, Target_product_id);
\end{lstlisting}

Listing 25: 建立交易請求狀態及目標商品索引

\subsection{在 MESSAGE 中加入請求代號的索引}

在本系統中，MESSAGE 表用於儲存買賣雙方的對話內容。當使用者查詢特定交易請求的對話紀錄時，系統需要基於「Request\_id」進行查詢。為了優化查詢效能，在此表中為「Request\_id」欄位建立索引，語法如下。

\begin{lstlisting}[language=SQL]
Create Index idx_message_request
On MESSAGE (Request_id);
\end{lstlisting}

Listing 26: 建立訊息請求代號索引

\subsection{在 REVIEW 中加入被評價者代號的索引}

在本系統中，REVIEW 表用於儲存交易評價。當使用者查詢特定使用者的評價時，系統需要基於「Reviewee\_id」進行查詢。為了優化查詢效能，在此表中為「Reviewee\_id」欄位建立索引，語法如下。

\begin{lstlisting}[language=SQL]
Create Index idx_review_reviewee
On REVIEW (Reviewee_id);
\end{lstlisting}

Listing 27: 建立評價被評價者索引

\newpage

\section{交易管理（Transaction Management）}

本系統在管理員功能中提供「批次匯入商品分類」功能，允許管理員上傳包含商品分類資訊的 CSV 檔案，系統會將檔案中的每個分類項目寫入資料庫。

此功能使用 Python 的 \texttt{psycopg2} 套件實作，程式碼位於 \texttt{./action/category\_management/UploadCategories.py}。該程式接收來自客戶端的 CSV 檔案，並呼叫 \texttt{./DB\_util.py} 中的 \texttt{upload\_categories} 函數。

\texttt{psycopg2} 預設會自動啟動交易（transaction），因此不需要手動執行 \texttt{BEGIN} 操作。程式會對每筆紀錄執行 \texttt{INSERT} 操作。

\textbf{錯誤處理：}若在插入過程中發生資料約束違反（例如分類名稱不能為空），插入過程會立即停止。系統接著使用 \texttt{db.rollback()} 方法回滾整個交易，取消所有先前的資料庫變更。此處 \texttt{db} 指的是 \texttt{psycopg2} 連線物件。

\textbf{成功情況：}若整個匯入過程成功完成，沒有任何資料一致性問題，系統會使用 \texttt{db.commit()} 來完成交易，確保所有分類資訊成功儲存至資料庫。

\newpage

\section{併行控制（Concurrency Control）}

在本系統中，使用者發起交易活動後，會進入商品交易請求流程。此交易請求流程需要併行控制。

\subsection{交易請求流程}

使用者首先查詢系統以尋找可交易商品，接著選擇想要的商品，填寫與交易請求相關的資訊（如出價金額、交換商品等），然後發送「新增請求」。系統接著檢查所選商品是否確實可被提出請求。若可請求，系統會儲存交易請求資訊。

\subsection{問題說明（Race Condition / Duplicate Request）}

上述交易請求流程需要鎖定機制以防止問題發生。若沒有適當的鎖定，可能會發生競爭條件（race condition）：

使用者 A 查詢並發現特定商品可被請求，接著選擇該商品、填寫資訊並發起請求。同時，使用者 B 也查詢，發現\emph{相同的}商品可被請求，並繼續進行請求。

若沒有實作併行控制（鎖定），該商品可能會被\emph{多個使用者同時提出請求}，導致「重複請求」的情況。從資料庫的角度來看，這意味著 TRADE\_REQUEST 表可能包含多筆記錄，其中 \texttt{Target\_product\_id} 相同，但 \texttt{Requester\_id} 不同，且狀態皆為 'Pending'，表示對同一商品存在衝突的請求。

\subsection{併行控制解決方案}

本文件建議兩種適合的方法來防止重複請求：

\subsubsection{方法一：在查詢可交易商品前鎖定}

在查詢可交易商品\emph{之前}取得鎖定。此鎖定可防止其他交易同時嘗試對相關商品進行請求或修改資訊，在從初始查詢到請求完成為止的整個期間內。只有在請求成功完成或明確取消後，才會釋放鎖定。此方法確保特定商品的請求狀態在該使用者的請求流程結束之前保持鎖定狀態。

\subsubsection{方法二：在「確認請求」後鎖定}

在使用者點擊「確認請求」按鈕\emph{之後}取得鎖定。此時，系統會執行\emph{第二次檢查}（重新查詢），以確認該商品的目標請求狀態是否仍然可用（即尚未被其他使用者提出請求）。若確認可用，則將新的請求記錄新增至 TRADE\_REQUEST 表，然後釋放鎖定。若發現不可用（已被請求），則不新增記錄，釋放鎖定，並在畫面上顯示錯誤訊息給使用者。此方法也能有效防止重複請求。

\subsection{選擇的方法與實作}

本系統選擇\emph{方法二}，原因如下：若在使用者真正確認並發送請求之前就套用鎖定（如方法一），可能會導致過長的等待時間。因此，我們選擇將併行控制集中在\emph{新請求發送之後}的流程，使用方法二來避免不必要的等待，並避免對系統效能造成潛在損害。

\subsubsection{實作細節}

此功能使用 Python 的 \texttt{threading} 套件實作。具體而言，在 \texttt{./DB\_util.py} 中的 \texttt{create\_trade\_request} 函數內：

\begin{enumerate}
    \item 使用 \texttt{lock.acquire()} 取得鎖定。
    \item 系統接著檢查該商品的目標請求狀態是否已被其他使用者提出請求。
    \item 若該商品\emph{未被請求}，則將新的請求記錄新增至資料庫，並使用 \texttt{lock.release()} 釋放鎖定，允許其他連線使用此函數。
    \item 若該商品\emph{已被請求}，則釋放鎖定，並回傳「請求失敗」訊息。
\end{enumerate}

此實作確保了在併發環境下，同一商品不會被多個使用者同時成功提出請求，從而維護了資料的一致性和系統的正確性。

\end{document}